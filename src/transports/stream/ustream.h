/*
    Copyright (c) 2016 Jack R. Dunaway. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom
    the Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.
*/

#ifndef NN_STREAM_INCLUDED
#define NN_STREAM_INCLUDED

#include "../../aio/fsm.h"
#include "../../aio/worker.h"

#define NN_USOCK_STATE_IDLE 0x0001
#define NN_USOCK_STATE_STARTING 0x0002
#define NN_USOCK_STATE_BEING_ACCEPTED 0x0003
#define NN_USOCK_STATE_ACCEPTED 0x0004
#define NN_USOCK_STATE_CONNECTING 0x0005
#define NN_USOCK_STATE_ACTIVE 0x0006
#define NN_USOCK_STATE_CANCELLING_IO 0x0007
#define NN_USOCK_STATE_DONE 0x0008
#define NN_USOCK_STATE_LISTENING 0x0009
#define NN_USOCK_STATE_ACCEPTING 0x000A
#define NN_USOCK_STATE_STOPPING 0x000B
#define NN_USOCK_STATE_CANCELLING_ACCEPT 0x000C
#define NN_USOCK_STATE_ACCEPTING_ERROR 0x000D

/*  State machine notifications common to stream subclasses. */
#define NN_STREAM_CONNECT_TIMEDOUT 0x00810000
#define NN_STREAM_HANDSHAKE_TIMEDOUT 0x00820000

/*  Event types generated by an underlying stream. */
#define NN_STREAM_CONNECTED 0x00910000
#define NN_STREAM_ACCEPTED 0x00920000
#define NN_STREAM_SENT 0x00930000
#define NN_STREAM_RECEIVED 0x00940000
#define NN_STREAM_ERROR 0x00950000
#define NN_STREAM_ACCEPT_ERROR 0x00960000
#define NN_STREAM_STOPPED 0x00970000
#define NN_STREAM_SHUTDOWN 0x00980000

/*  Commands to the underlying stream object to trigger state transitions. */
#define NN_STREAM_START_ACCEPTING 0x00A10000
#define NN_STREAM_START_BEING_ACCEPTED 0x00A20000
#define NN_STREAM_CANCEL_ACCEPT 0x00A30000
#define NN_STREAM_START_LISTENING 0x00A40000
#define NN_STREAM_START_CONNECTING 0x00A50000
#define NN_STREAM_ACTIVATE 0x00A60000

/*  Maximum number of iovecs that can be passed to the send function. */
#define NN_STREAM_MAX_IOVCNT 3

struct nn_stream {

    /*  The state machine. */
    struct nn_fsm fsm;
    int state;

    /*  Underlying OS file descriptor. */
    nn_fd fd;

    /*  The worker thread that handles async I/O operations for this stream. */
    struct nn_worker *worker;

    /*  Events raised to the owner of this underlying stream. */
    struct nn_fsm_event established;
    struct nn_fsm_event sent;
    struct nn_fsm_event received;
    struct nn_fsm_event errored;

    /*  In ACCEPTING state points to the socket being accepted.
        In BEING_ACCEPTED state points to the listener socket. */
    //struct nn_fsm *asock;

    /*  Asynchronous directed operation currently in progress on this
        full-duplex stream. */
    //struct nn_task_io incoming;
    //struct nn_task_io outgoing;

    /*  Asynchronous tasks for the worker. */
    struct nn_task_io task_connecting;
    struct nn_task_io task_connected;
    struct nn_task_io task_accept;
    struct nn_task_io task_send;
    struct nn_task_io task_recv;
    struct nn_task_io task_stop;

    /*  Virtual function table for stream subclass overrides. */
    struct nn_stream_vfptr *vft;

    /*  Errno remembered in NN_STREAM_ERROR state. */
    int err;
};

/*  Virtual function pointer table for stream subclass overrides. Transports
    implement these functions, abstracting such transport-specific syntax and
    linkages from this transport-agnostic nanomsg protocol control flow. */
struct nn_stream_vfptr {

    /*  Notify the underlying transport that a message has been sent. */
    int (*sent) (struct nn_stream *s);

    /*  Request the underlying transport to cancel an active I/O operation. */
    int (*cancel_io) (struct nn_stream *s);

    /*  Begin name resolution for the endpoint address. */
    int (*start_resolve) (struct nn_cstream *cstream);

    /*  Begin connecting to peer endpoint address. */
    int (*start_connect) (struct nn_cstream *cstream);

    /*  Begin connecting to peer endpoint address. */
    int (*start_listen) (struct nn_stream *s, struct nn_epbase *e);

    /*  Set socket options on an accepted stream. */
    int (*tune) (struct nn_stream *s, struct nn_epbase *e);

    /*  When all the tuning is done on the accepted socket, call this function
        to activate standard data transfer phase of the pipe. */
    int (*activate) (struct nn_astream *as);

    /*  Tell the underlying transport to completely uninitialize in preparation
        to be deallocated. */
    int (*close) (struct nn_stream *s);
};

/*  Stream lifetime. */
void nn_stream_init (struct nn_stream *self, struct nn_fsm *owner,
    struct nn_stream_vfptr *vft);
void nn_stream_term (struct nn_stream *self);

/*  Transfers ownership of an underlying stream to another object. */
void nn_stream_swap_owner (struct nn_stream *self,
    struct nn_fsm *newowner);

/*  Returns 1 if the stream has pending I/O operations and 0 otherwise. */
int nn_stream_pending (struct nn_stream *self);

/*  Returns 1 if async cancellation has begun and 0 if there were no pending
    operations to cancel. */
int nn_stream_cancel_io (struct nn_stream *self);



int nn_stream_isidle (struct nn_stream *self);
int nn_stream_start (struct nn_stream *self, int domain, int type, int protocol);
void nn_stream_stop (struct nn_stream *self);

int nn_stream_setsockopt (struct nn_stream *self, int level, int optname,
    const void *optval, size_t optlen);

int nn_stream_bind (struct nn_stream *self, const struct sockaddr *addr,
    size_t addrlen);
int nn_stream_listen (struct nn_stream *self, int backlog);

/*  Accept a new connection from a listener. When done, NN_STREAM_ACCEPTED
    event will be delivered to the accepted socket. To cancel the operation,
    stop the socket being accepted. Listening socket should not be stopped
    while accepting a new socket is underway. */
void nn_stream_accept (struct nn_stream *self, struct nn_stream *listener);

/*  Start connecting. Prior to this call the socket has to be bound to a local
    address. When connecting is done, NN_STREAM_CONNECTED event will be raised.
    If connecting fails NN_STREAM_ERROR event will be raised. */
void nn_stream_connect (struct nn_stream *self, const struct sockaddr *addr,
    size_t addrlen);

void nn_stream_send (struct nn_stream *self, const struct nn_iovec *iov,
    int iovcnt);

void nn_stream_recv (struct nn_stream *self, void *buf, size_t len);


#endif
